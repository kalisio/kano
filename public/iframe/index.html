<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="format-detection" content="telephone=no">
    <meta name="msapplication-tap-highlight" content="no">
    <meta name="viewport" content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width">

    <title>Kano IFrame integration</title>
    <link rel="shortcut icon" type="image/x-icon" href="../icons/kano-icon-32x32.png">
    <script src="./flightpath.js"></script>
    <script src="./flightradar.js"></script>
    <script src='./dependencies/turf.min.js'></script>
    <script src="./dependencies/post-robot.min.js"></script>
    <script src="./dependencies/chroma.min.js"></script>
    <script>
      var layerIsShown = false
      var component = 'map'
      var airports, aircraft

      function getGeoJsonAircraftFeature () {
        var long = 1.444209 + 0.1 * (Math.random() - 0.5)
        var lat = 43.604652 + 0.1 * (Math.random() - 0.5)
        var alt = 8519.16 + 1000 * (Math.random() - 0.5)
        var track = 360 * Math.random()
        var speed = 300 // miles / h
        // Compute speed vector data for 3/5/10 minutes
        // We duplicate points to avoid color interpolation and we insert points to control opacity
        /*
        var durations = [0, 3, 5, 10]
        var colors = ['red', 'yellow', 'blue']
        var speedVectors = []
        for (var i = 0; i < 3; i++) {
          var color = colors[i]
          var domain = [durations[i], durations[i+1] - 1, durations[i+1]]
          var colorramp = chroma.scale([
            chroma(color).alpha(0),
            chroma(color).alpha(0),
            chroma(color).alpha(1)]).domain(domain)
          var destinations = domain.map(duration => turf.destination([long, lat], duration * speed / 60, track, { units: 'miles' }))
          speedVectors.push({
            type: 'Feature',
            properties: { id: i+1, gradient: domain.map(duration => colorramp(duration).hex()), weight: 8 },
            geometry: {
              type: 'LineString',
              coordinates: destinations.map(destination => destination.geometry.coordinates)
            }
          })
        }
        */
        aircraft = {
          type: 'FeatureCollection',
          features: [
            {
              type: 'Feature',
              properties: {
                id: 0,
                callsign: 'AIB03KM',
                track: track,
                type: (Math.random() > 0.5 ? 'a380' : 'a320')
              },
              geometry: {
                type: 'Point',
                coordinates: [long, lat, alt]
              }
            }
          ]//.concat(speedVectors)
        }
        return aircraft
      }
      function getGeoJsonAcarsFeature (id) {
        var type = (Math.random() < 0.3 ? 'ATC' : (Math.random() > 0.7 ? 'AOC' : 'AAC'))
        var separator = (component === 'globe' ? '\n' : '</br>')
        var message = `OUT 13:29Z /ZFW 113840 /FOB 13830 /TAW 127670${separator}/POS N50 2.3924 E8 35.1521${separator}/ALT 372${separator}/AP EDDF /GATE A 10${separator}/WND 08008 /OAT 17 /TAT 18`
        let feature = {
          type: 'Feature',
          properties: {
            id,
            type,
            timestamp: new Date(Date.now() + 1000 * 60 * 60 * (Math.random() - 0.5)),
            message
          },
          geometry: {
            type: 'Point'
          }
        }
        return feature
      }
      function toggleGlobe() {
        component = (component === 'globe' ? 'map' : 'globe')
        return postRobot.send(kano, component)
      }
      async function toggleStaticLayer(name) {
        await postRobot.send(kano, component, { command: (layerIsShown ? 'hideLayer' : 'showLayer'), args: name })
        layerIsShown = !layerIsShown
        if (layerIsShown) await postRobot.send(kano, component, { command: 'zoomToLayer', args: name })
      }
      async function toggleBackground() {
        const result = await postRobot.send(kano, component, { command: 'isLayerVisible', args: 'Layers.OSM_DARK' })
        // Switch between Satellite/OSM
        await postRobot.send(kano, component, { command: 'showLayer', args: (result.data ? 'Layers.OSM_BRIGHT' : 'Layers.OSM_DARK') })
        await postRobot.send(kano, component, { command: 'hideLayer', args: (!result.data ? 'Layers.OSM_BRIGHT' : 'Layers.OSM_DARK') })
      }
      async function toggleAircraftLayer(name) {
        const result = await postRobot.send(kano, component, { command: 'isLayerVisible', args: name })
        if (result.data) {
          return postRobot.send(kano, component, { command: 'removeLayer', args: name })
        } else {
          await postRobot.send(kano, component, { command: 'addLayer', args: {
            name,
            type: 'OverlayLayer',
            icon: 'local_airport',
            featureId: 'callsign',
            leaflet: {
              type: 'geoJson',
              realtime: true,
              isVisible: true,
              'icon-html': '<span style="display: inline-block; transformOrigin: 16px 16px; transform: rotateZ(<%= properties.track + bearing %>deg)"><img width="32px" height="32px" src="/iframe/<%= properties.type %>.png"/></span>',
              /* We can also use SVG
              'icon-html': '<span style="display: inline-block; transformOrigin: 16px 16px; transform: rotateZ(<%= bearing ? bearing - properties.track : properties.track %>deg)"><svg width="32px" height="32px" viewBox="0 0 512 512"><path fill="green" d="M281.7 311.9c.4-6.9 8.3-4.5 8.3-4.5l62 12.6 128 48.7c0-24-3.8-26.5-9.4-30.7L288 207s-4.9-60-4.9-112.9c0-24.5-11.8-78.1-27.1-78.1s-27.1 54.4-27.1 78.1c0 50.2-4.9 112.9-4.9 112.9L41.4 338c-7.1 5-9.4 7.7-9.4 30.7L160 320l61.9-12.6s7.9-2.4 8.3 4.5c.4 6.9-1.2 69.1 5.9 102.1.9 4.4-2.5 4.7-4.8 7.4l-51.9 32.8c-1.7 1.9-2.5 7.3-2.5 7.3l-1 18.5 68-16 12 32 12-32 68 16-1-18.5c.1 0-.7-5.4-2.4-7.3l-51.9-32.8c-2.3-2.7-5.7-3-4.8-7.4 6.9-33 5.5-95.2 5.9-102.1z"/></svg></span>',
              */
              'icon-anchor': [16, 16],
              'marker-size': 32,
              'marker-symbol': 'none',
              template: ['icon-html'],
              popup: { pick: [] },
              tooltip: {
                template: '<%= properties.callsign %>'
              }
            },
            cesium: {
              type: 'geoJson',
              realtime: true,
              isVisible: true,
              'marker-symbol': 'airport',
              'marker-color': '#57D824',
              entityStyle: {
                model: {
                  type: 'Cesium.ModelGraphics',
                  options: {
                    uri: '/iframe/<%= properties.type %>.glb',
                    minimumPixelSize: 64,
                    scale: 0.1
                  },
                },
                // Orientation as heading, pitch, roll
                orientation: '<%= properties.track %>,0,0',
                localFrameAxes: ['east', 'north'],
                template: ['model.options.uri', 'orientation']
              },
              popup: { pick: [] },
              tooltip: {
                template: '<%= properties.callsign %>'
              }
            }
          }})
          await updateAircraftLayer(name)
        }
      }
      async function updateAircraftLayer(name) {
        var geoJson = getGeoJsonAircraftFeature()
        var long = geoJson.features[0].geometry.coordinates[0]
        var lat = geoJson.features[0].geometry.coordinates[1]
        await postRobot.send(kano, component, { command: 'updateLayer', args: [name, geoJson] })
        // Use zoom level or altitude depending on mode
        await postRobot.send(kano, component, { command: 'center', args: [long, lat, (component === 'globe' ? 10000 : 12)] })
      }
      async function toggleMetarTafLayer(name) {
        const result = await postRobot.send(kano, component, { command: 'isLayerVisible', args: name })
        if (result.data) {
          await postRobot.send(kano, component, { command: 'removeLayer', args: name })
        } else {
          await postRobot.send(kano, component, { command: 'addLayer', args: {
            name,
            type: 'OverlayLayer',
            icon: 'wb_sunny',
            featureId: 'ICAO',
            leaflet: {
              type: 'geoJson',
              realtime: true,
              isVisible: true,
              container: 'markerClusterGroup',
              /* We can use SVG
              'icon-html': '<svg height="16" width="16"><circle cx="8" cy="8" r="6" fill-opacity="0.5" stroke-width="0"\
                              fill="<% if (properties.visibility < 75) { %>#000000<% }\
                                    else if (properties.visibility < 300) { %>#d20200<% }\
                                    else if (properties.visibility < 1500) { %>#f9b40f<% }\
                                    else if (properties.visibility < 3000) { %>#eef52f<% }\
                                    else { %>#33c137<% } %>"/>\
                            </svg>',
              'icon-anchor': [8, 8],
              'marker-size': 16,
              template: ['icon-html'],
              */
              /* We can use font-awesome icons
              'icon-classes': 'fa fa-sun-o',
              'icon-color': '#000000',
              'icon-x-offset' : -2,
              'icon-y-offset' : 0,
              'marker-color': `<% if (properties.visibility < 75) { %>#000000<% }
                                  else if (properties.visibility < 300) { %>#d20200<% }
                                  else if (properties.visibility < 1500) { %>#f9b40f<% }
                                  else if (properties.visibility < 3000) { %>#eef52f<% }
                                  else { %>#33c137<% } %>`,
              template: ['marker-color'],
              */
              /* We can use images
              'marker-symbol': `<% if (properties.visibility < 75) { %>/iframe/windyblack.png<% }
                                  else if (properties.visibility < 300) { %>/iframe/windyred.png<% }
                                  else if (properties.visibility < 1500) { %>/iframe/windyorange.png<% }
                                  else if (properties.visibility < 3000) { %>/iframe/windyyellow.png<% }
                                  else { %>/iframe/windygreen.png<% } %>`,
              'marker-size': [24, 30],
              template: ['marker-symbol'],
              */
              /* We can use HTML */
              'icon-html': `<b style="display: inline-block; color:#000;
                              text-shadow:-1px -1px 0 #FFF,1px -1px 0 #FFF,-1px 1px 0 #FFF,1px 1px 0 #FFF;">
                              <%= properties.ICAO %>
                            </b>
                            <img style="display: inline-block;" width="24px" height="30px" src="
                              <% if (properties.visibility < 75) { %>/iframe/windyblack.png<% }
                                else if (properties.visibility < 300) { %>/iframe/windyred.png<% }
                                else if (properties.visibility < 1500) { %>/iframe/windyorange.png<% }
                                else if (properties.visibility < 3000) { %>/iframe/windyyellow.png<% }
                                else { %>/iframe/windygreen.png<% } %>"/>
                            `,
              'icon-anchor': [12, 32],
              'marker-symbol': 'none',
              template: ['icon-html'],
              popup: { pick: [] },
              tooltip: {
                template: '<b>METAR</b></br><%= properties.metar %></br><b>TAF</b></br><%= properties.taf %>'
              }
            },
            cesium: {
              type: 'geoJson',
              realtime: true,
              isVisible: true,
              cluster: {
                pixelRange: 50
              },
              entityStyle: {
                billboard: {
                  scale: 0.5,
                  image: `<% if (properties.visibility < 75) { %>/iframe/windyblack.png<% }
                            else if (properties.visibility < 300) { %>/iframe/windyred.png<% }
                            else if (properties.visibility < 1500) { %>/iframe/windyorange.png<% }
                            else if (properties.visibility < 3000) { %>/iframe/windyyellow.png<% }
                            else { %>/iframe/windygreen.png<% } %>`,
                  color: `Cesium.Color.<% if (properties.visibility < 75) { %>BLACK<% }
                            else if (properties.visibility < 300) { %>ORANGERED<% }
                            else if (properties.visibility < 1500) { %>GOLD<% }
                            else if (properties.visibility < 3000) { %>YELLOW<% }
                            else { %>LIMEGREEN<% } %>`
                },
                template: ['billboard.image', 'billboard.color']
              },
              popup: { pick: [] },
              tooltip: {
                template: 'METAR\n<%= properties.metar %>\nTAF\n<%= properties.taf %>'
              }
            }
          }})
          await updateMetarTafLayer(name)
          setTimeout(() => postRobot.send(kano, component, { command: 'zoomToLayer', args: name }), 1000)
        }
      }
      function updateMetarTafLayer(name) {
        // Setup random visibility on some airports
        airports.features.forEach(function(airport) {
          var visibility = 5000 * Math.random()
          airport.properties.visibility = visibility
          airport.properties.metar = 'KAUS 092135Z 26018G25KT 8SM -TSRA BR SCT045CB BKN060 OVC080 30/21 A2992'
          airport.properties.taf = 'KOKC 051130Z 051212 14008KT 5SM BR BKN030 TEMPO 1316 1 1/2SM BR'
        })
        // Filter airports as all don't have METAR/TAF information
        return postRobot.send(kano, component, { command: 'updateLayer', args: [name, { type: 'FeatureCollection', features: airports.features.slice(0, 100) }] })
      }
      async function toggleAcarsLayer(name) {
        const result = await postRobot.send(kano, component, { command: 'isLayerVisible', args: name })
        if (result.data) {
          await postRobot.send(kano, component, { command: 'removeLayer', args: name })
        } else {
          await postRobot.send(kano, component, { command: 'addLayer', args: {
            name,
            type: 'OverlayLayer',
            icon: 'message',
            featureId: 'id',
            isSelectable: false,
            leaflet: {
              type: 'geoJson',
              realtime: true,
              isVisible: true,
              'marker-symbol' : 'circle',
              'radius': 6,
              'stroke-width': 0,
              'fill-opacity': 0.75,
              'fill': `<% if (properties.type === 'ATC') { %>#000000<% }
                              else if (properties.type === 'AOC') { %>#f9b40f<% }
                              else { %>#33c137<% } %>`,
              template: ['fill'],
              cluster: null,
              popup: { pick: [] },
              tooltip: {
                template: '<b><%= properties.timestamp.toISOString() %></b></br><%= properties.message %>'
              },
              // Use higher value than default overlays to ensure messages are always on top of flightpath
              // (see https://leafletjs.com/reference-1.4.0.html#map-overlaypane)
              zIndex: 401
            },
            cesium: {
              type: 'geoJson',
              realtime: true,
              isVisible: true,
              'marker-symbol' : 'circle',
              entityStyle: {
                billboard: {
                  image: `<% if (properties.type === 'ATC') { %>/iframe/ACMS.png<% }
                            else if (properties.type === 'AOC') { %>/iframe/AOC.png<% }
                            else { %>/iframe/ADS.png<% } %>`,
                  color: `Cesium.Color.<% if (properties.type === 'ATC') { %>BLACK<% }
                            else if (properties.type === 'AOC') { %>ORANGE<% }
                            else { %>LIMEGREEN<% } %>`,
                  heightReference : 'Cesium.HeightReference.RELATIVE_TO_GROUND'
                },
                template: ['billboard.image', 'billboard.color']
              },
              popup: { pick: [] },
              tooltip: {
                template: '<%= properties.timestamp.toISOString() %>\n<%= properties.message %>'
              }
            }
          }})
          await updateAcarsLayer(name)
          setTimeout(() => postRobot.send(kano, component, { command: 'zoomToLayer', args: name }), 1000)
        }
      }
      function updateAcarsLayer(name) {
        // Setup random messages
        let acars = { type: 'FeatureCollection', features: [] }
        for (let i = 0; i < flightpath.length; i++) {
          let feature = getGeoJsonAcarsFeature(i)
          feature.geometry.coordinates = flightpath[i].concat(10000 * Math.random()) // Random altitude
          feature.style = { draggable: true }
          acars.features.push(feature)
        }
        // Filter airports as all don't have METAR/TAF information
        return postRobot.send(kano, component, { command: 'updateLayer', args: [name, acars] })
      }
      async function toggleFlightpathLayer(name) {
        const result = await postRobot.send(kano, component, { command: 'isLayerVisible', args: name })
        if (result.data) {
          await postRobot.send(kano, component, { command: 'removeLayer', args: name })
        } else {
          await postRobot.send(kano, component, { command: 'addLayer', args: {
            name,
            type: 'OverlayLayer',
            icon: 'timeline',
            featureId: 'id',
            leaflet: {
              type: 'geoJson',
              realtime: true,
              isVisible: true,
              popup: { pick: [] },
              tooltip: {
                template: '<%= properties.message %>',
                options: { sticky: true }
              }
            },
            cesium: {
              type: 'geoJson',
              realtime: true,
              isVisible: true,
              popup: { pick: [] },
              tooltip: {
                template: '<%= properties.message %>',
                options: { sticky: true }
              },
              entityStyle: {
                polyline: {
                  clampToGround: false
                }
              }
            }
          }})
          await updateFlightpathLayer(name)
          setTimeout(() => postRobot.send(kano, component, { command: 'zoomToLayer', args: name }), 1000)
        }
      }
      function updateFlightpathLayer(name) {
        // Setup random path
        let coordinates = flightpath.map(function(point) {
          return [ point[0] + 0.01 * (Math.random() - 0.5),
                   point[1] + 0.01 * (Math.random() - 0.5),
                   1000 * Math.random() ] // Random altitude
        })
        let path = { type: 'FeatureCollection', features: [] }
        let middle = parseInt(coordinates.length / 2)
        let random = Math.random()
        path.features.push({
          type: 'Feature',
          properties: { id: 0, message: 'ADS-B KO', stroke: random > 0.5 ? '#000000' : '#00FF00', weight: 1 + 5 * random, offset: -5,
            entityStyle: { polyline: { clampToGround: true } } },
          geometry: { type: 'LineString', coordinates: coordinates.slice(0, middle + Math.ceil(flightpath.length % 2))}
        })
        // Same with offset
        path.features.push({
          type: 'Feature',
          properties: { id: 1, message: 'ADS-B KO', stroke: random > 0.5 ? '#00FF00' : '#000000', weight: 10, 'dash-array': '3, 20', 'line-cap': 'round', 'line-join': 'round', offset: 5,
            entityStyle: { polyline: { clampToGround: true, material: { type: 'Cesium.PolylineDashMaterialProperty', options: { dashPattern: 255, color: random > 0.5 ? 'Cesium.Color.BLUEVIOLET' : 'Cesium.Color.AQUA' }  } } } },
          geometry: { type: 'LineString', coordinates: coordinates.slice(0, middle + Math.ceil(flightpath.length % 2))}
        })
        const weight = 5 + 5 * random
        path.features.push({
          type: 'Feature',
          properties: { id: 2, message: 'ADS-B OK', stroke: random > 0.5 ? '#00FFFF' : '#FF00FF', weight,
            entityStyle: { polyline: { clampToGround: true, zIndex: 0 } } },
          geometry: { type: 'LineString', coordinates: coordinates.slice(middle - 1, flightpath.length)}
        })
        // Same but thiner
        path.features.push({
          type: 'Feature',
          properties: { id: 3, message: 'ADS-B OK', stroke: random > 0.5 ? '#FF00FF' : '#00FFFF', weight: weight - 4,
            entityStyle: { polyline: { clampToGround: true, zIndex: 1 } } },
          geometry: { type: 'LineString', coordinates: coordinates.slice(middle - 1, flightpath.length)}
        })
        // Filter airports as all don't have METAR/TAF information
        return postRobot.send(kano, component, { command: 'updateLayer', args: [name, path] })
      }
      async function toggleGradientFlightpathLayer(name) {
        const result = await postRobot.send(kano, component, { command: 'isLayerVisible', args: name })
        if (result.data) {
          await postRobot.send(kano, component, { command: 'removeLayer', args: name })
        } else {
          await postRobot.send(kano, component, { command: 'addLayer', args: {
            name,
            type: 'OverlayLayer',
            icon: 'timeline',
            featureId: 'id',
            leaflet: {
              type: 'geoJson',
              realtime: true,
              isVisible: true,
              popup: { pick: ['message'] },
              tooltip: {
                template: '<%= properties.message %>',
                options: { sticky: true }
              }
            },
            cesium: {
              type: 'geoJson',
              realtime: true,
              isVisible: true,
              popup: { pick: [] },
              tooltip: {
                template: '<%= properties.message %>',
                options: { sticky: true }
              }
            }
          }})
          await updateGradientFlightpathLayer(name)
          setTimeout(() => postRobot.send(kano, component, { command: 'zoomToLayer', args: name }), 1000)
        }
      }
      function updateGradientFlightpathLayer(name) {
        // Filter according to current batch
        let filter = function (value, index) {
          return index <= (coords.length * split)
        }
        let colorramp = chroma.scale([
          'white',  //0
          'yellow', // 2000
          'yellow', // 3000
          'green',  // 5000 
          'green',  // 8000
          'lightblue', // 10000
          'lightblue', // 18000
          'navy', // 20000
          'navy', // 33000
          'purple', //35000
          'purple']).domain([0, 2000, 3000, 5000, 8000, 10000, 18000, 20000, 33000, 35000, 50000].map(value => value))
        let path = { type: 'FeatureCollection', features: [] }
        // Compute color properties based on color scale
        let gradient = heights.filter(filter).map(height => colorramp(height).hex())
        let coordinates = coords.filter(filter)
        path.features.push({
          type: 'Feature',
          properties: { id: 0, gradient, weight: 8, message: 'ADS-B OK' },
          geometry: { type: 'LineString', coordinates }
        })
        // Add a second part with standard geojson styling
        path.features.push({
          type: 'Feature',
          properties: { id: 1, message: 'ADS-B KO', stroke: Math.random() > 0.5 ? '#000000' : '#FFFF00',
                        weight: 1 + 5 * Math.random(), 'dash-array': '20, 20' },
          geometry: { type: 'LineString', coordinates: [ coordinates[0], coordinates[coordinates.length - 1] ] }
        })
        // Jump to next batch
        split += 1.0 / 3.0
        if (split > 1) split = 1.0 / 3.0
        return postRobot.send(kano, component, { command: 'updateLayer', args: [name, path] })
      }
      async function toggleFlightplanLayer(name) {
        const result = await postRobot.send(kano, component, { command: 'isLayerVisible', args: name })
        if (result.data) {
          await postRobot.send(kano, component, { command: 'removeLayer', args: name })
        } else {
          await postRobot.send(kano, component, { command: 'addLayer', args: {
            name,
            type: 'OverlayLayer',
            icon: 'multiline_chart',
            featureId: 'name',
            leaflet: {
              type: 'geoJson',
              realtime: true,
              isVisible: true,
              popup: { pick: [] },
              cluster: false,
              panes: [{
                name: 'waypoints',
                minZoom: 7,
                //maxZoom: 14
              }]
            },
            cesium: {
              type: 'geoJson',
              realtime: true,
              isVisible: true,
              popup: { pick: [] },
              entityStyle: {
                billboard: {
                  heightReference: 'Cesium.HeightReference.RELATIVE_TO_GROUND'
                },
                label: {
                  heightReference: 'Cesium.HeightReference.RELATIVE_TO_GROUND'
                },
                polyline: {
                  clampToGround: false
                }
              }
            }
          }})
          await updateFlightplanLayer(name)
          setTimeout(() => postRobot.send(kano, component, { command: 'zoomToLayer', args: name }), 1000)
        }
      }
      function updateFlightplanLayer(name) {
        let plan = { type: 'FeatureCollection', features: [] }
        // Departure/Arrival airports
        plan.features.push({
          type: 'Feature',
          properties: { name: 'TOULOUSE BLAGNAC', 'marker-symbol' : 'circle', 'radius': 10, 'stroke': '#33c137',
                        'stroke-opacity': 1, 'stroke-width': 0, 'fill': '#33c137', 'fill-opacity': 0.5,
                        tooltip: { property: ['name'] } },
          geometry: { type: 'Point', coordinates: [ 1.368333, 43.635, 499.0 ] }
        })
        plan.features.push({
          type: 'Feature',
          properties: { name: 'WILEY POST-WILL ROGERS', 'marker-symbol' : 'circle', 'radius': 10, 'stroke': '#33c137',
                        'stroke-opacity': 1, 'stroke-width': 0, 'fill': '#33c137', 'fill-opacity': 0.5,
                        tooltip: { property: ['name'] } },
          geometry: { type: 'Point', coordinates: [ -156.763333, 71.286667, 44.0 ] }
        })
        // Alternative Departure/Arrival airports
        plan.features.push({
          type: 'Feature',
          properties: { name: 'TOULOUSE MONTAUDRAN', 'marker-symbol' : 'circle', 'radius': 10, 'stroke': '#f9b40f',
                        'stroke-opacity': 1, 'stroke-width': 0, 'fill': '#f9b40f', 'fill-opacity': 0.5,
                        tooltip: { property: ['name'] } },
          geometry: { type: 'Point', coordinates: [ 1.473333, 43.568333, 0.0 ] }
        })
        plan.features.push({
          type: 'Feature',
          properties: { name: 'BARTER ISLAND LRRS', 'marker-symbol' : 'circle', 'radius': 10, 'stroke': '#f9b40f',
                        'stroke-opacity': 1, 'stroke-width': 0, 'fill': '#f9b40f', 'fill-opacity': 0.5,
                        tooltip: { property: ['name'] } },
          geometry: { type: 'Point', coordinates: [ -143.578333, 70.135, 0.0 ] }
        })
        // Path
        plan.features.push({
          type: 'Feature',
          properties: { name: 'FLIGHTPATH', geodesic: true, wall: true, 'stroke': '#33c137', 'stroke-opacity': 1, 'stroke-width': 5,
            'fill': '#f9b40f', 'fill-opacity': 0.5,
            entityStyle: {
              polyline: { arcType: 'Cesium.ArcType.GEODESIC' },
              wall: { distanceDisplayCondition: { type: 'Cesium.DistanceDisplayCondition', options: [0.0, 1000000.0] } }
            }
          },
          geometry: { type: 'LineString', coordinates: [
            [ 1.368333, 43.635, 49900.0 ], // TOULOUSE
            [ 2.548333, 49.01, 39000.0 ], // PARIS
            [ -6.27, 53.421667, 24200.0 ], // DUBLIN
            [ -156.763333, 71.286667, 4400.0 ] // WILEY POST-WILL ROGERS
          ] }
        })
        // Waypoints
        plan.features.push({
          type: 'Feature',
          properties: { name: 'PARIS-WAYPOINT', 'marker-symbol': 'none', 'icon-anchor': [4, 8], 'icon-html': '<div style="display: inline-block; height: 8px; width: 8px; background: #33c13799; transform: rotate(45deg);">', pane: 'waypoints',
            entityStyle: {
              billboard: { distanceDisplayCondition: { type: 'Cesium.DistanceDisplayCondition', options: [0.0, 1000000.0] } }
            }
          },
          geometry: { type: 'Point', coordinates: [ 2.548333, 49.01, 39000.0 ] }
        })
        plan.features.push({
          type: 'Feature',
          properties: { name: 'PARIS-WAYPOINT-LABEL', 'marker-symbol': 'none', 'icon-anchor': [-8, 8], 'icon-html': '<b style="display: inline-block; color:#33c137;">PARIS</b>', 'fill': '#33c137', 'stroke': '#33c137', 'icon-text': 'PARIS', pane: 'waypoints',
            entityStyle: {
              billboard: { distanceDisplayCondition: { type: 'Cesium.DistanceDisplayCondition', options: [0.0, 1000000.0] } },
              label: { font: '18px sans-serif', pixelOffset : { type: 'Cesium.Cartesian2', options: [32, 0] },
                       distanceDisplayCondition: { type: 'Cesium.DistanceDisplayCondition', options: [0.0, 1000000.0] } }
            }
          },
          geometry: { type: 'Point', coordinates: [ 2.548333, 49.01, 39000.0 ] }
        })
        plan.features.push({
          type: 'Feature',
          properties: { name: 'DUBLIN-WAYPOINT', 'marker-symbol': 'none', 'icon-anchor': [4, 8], 'icon-html': '<div style="display: inline-block; height: 8px; width: 8px; background: #33c13799; transform: rotate(45deg);">', pane: 'waypoints',
            entityStyle: {
              billboard: { distanceDisplayCondition: { type: 'Cesium.DistanceDisplayCondition', options: [0.0, 1000000.0] } }
            }
          },
          geometry: { type: 'Point', coordinates: [ -6.27, 53.421667, 24200.0 ] }
        })
        plan.features.push({
          type: 'Feature',
          properties: { name: 'DUBLIN-WAYPOINT-LABEL', 'marker-symbol': 'none', 'icon-anchor': [-8, 8], 'icon-html': '<b style="display: inline-block; color:#33c137;">DUBLIN</b>', 'icon-text': 'DUBLIN', pane: 'waypoints',
            entityStyle: {
              billboard: { distanceDisplayCondition: { type: 'Cesium.DistanceDisplayCondition', options: [0.0, 1000000.0] } },
              label: { font: '18px sans-serif', pixelOffset : { type: 'Cesium.Cartesian2', options: [32, 0] },
                       distanceDisplayCondition: { type: 'Cesium.DistanceDisplayCondition', options: [0.0, 1000000.0] } }
            }
          },
          geometry: { type: 'Point', coordinates: [ -6.27, 53.421667, 24200.0 ] }
        })
        // ETOPS
        plan.features.push({
          type: 'Feature',
          properties: { name: 'KEFLAVIK AIRPORT ETOPS', geodesic: true, 'radius': 1500000, 'stroke': '#00bfff',
                        'stroke-opacity': 1, 'stroke-width': 1, 'fill': '#00bfff', 'fill-opacity': 0.5,
                        popup: { html: 'KEFLAVIK ETOPS ZONE', text: 'KEFLAVIK ETOPS ZONE' } },
          geometry: { type: 'Point', coordinates: [ -22.6055, 63.985, 171.0 ] }
        })
        plan.features.push({
          type: 'Feature',
          properties: { name: 'KEFLAVIK AIRPORT', 'marker-symbol' : 'circle', 'radius': 10, 'stroke': '#0000ff',
                        'stroke-opacity': 1, 'stroke-width': 0, 'fill': '#0000ff', 'fill-opacity': 0.5,
                        tooltip: { property: 'name' } },
          geometry: { type: 'Point', coordinates: [ -22.6055, 63.985, 171.0 ] }
        })
        return postRobot.send(kano, component, { command: 'updateLayer', args: [name, plan] })
      }
      async function updateForecastLevel() {
        let result = await postRobot.send(kano, component, { command: 'showLayer', args: 'Wind (isobaric)' })
        result = await postRobot.send(kano, component, { property: 'selectableLevels' })
        const index = Math.floor(Math.random() * result.data.values.length)
        const level = result.data.values[index]
        await postRobot.send(kano, component, { command: 'setSelectedLevel', args: [level] })
      }
      async function updateBearing() {
        const result = await postRobot.send(kano, component, { command: 'getCenter' })
        const { longitude, latitude, zoomLevel, altitude } = result.data
        if (component === 'map') {
          await postRobot.send(kano, component, { command: 'center', args: [longitude, latitude, zoomLevel, -360 * Math.random()] })
          await postRobot.send(kano, 'map', { command: 'setTouchRotateEnabled', args: true })
        } else await postRobot.send(kano, component, { command: 'center', args: [longitude, latitude, altitude, 0, -90, -360 * Math.random()] })
        // Refresh A/C orientation
        await postRobot.send(kano, component, { command: 'updateLayer', args: ['Aircraft', aircraft] })
      }
      async function resetBearing() {
        const result = await postRobot.send(kano, component, { command: 'getCenter' })
        const { longitude, latitude, zoomLevel, altitude } = result.data
        if (component === 'map') {
          await postRobot.send(kano, 'map', { command: 'setTouchRotateEnabled', args: false })
          await postRobot.send(kano, component, { command: 'center', args: [longitude, latitude, zoomLevel, 0] })
        } else await postRobot.send(kano, component, { command: 'center', args: [longitude, latitude, altitude, 0, -90, 0] })
        // Refresh A/C orientation
        await postRobot.send(kano, component, { command: 'updateLayer', args: ['Aircraft', aircraft] })
      }
    </script>
    <style>
      html, body {
          margin: 0;
          height: 100%;
          min-height: 100%;
          background: grey;
      }
      .toplevel-container {
          display: flex;
          flex-direction: row;
          min-height: 100%;
      }
      .button-container {
          flex: 0 1 auto;
          gap: 10px;
          grid-auto-rows: min-content;
      }
      .packed-grid {
          display: grid;
      }
      .iframe-container {
          flex: 1 1 auto;
      }
      .iframe-container iframe {
          border: 0;
          margin: 0;
          padding: 0;
          height: 100%;
          width: 100%;
      }
    </style>
  </head>
  <body>
    <div class="toplevel-container">
      <div class="button-container packed-grid">
        <div class="packed-grid">
          <button type="button" onclick="toggleGlobe()">Switch 2D/3D</button>
          <button type="button" onclick="toggleBackground()">Switch background</button>
        </div>
        <button type="button" onclick="toggleStaticLayer('Layers.AIRPORTS')">Switch airports</button>
        <div class="packed-grid">
          <button type="button" onclick="toggleMetarTafLayer('METAR')">Switch METAR</button>
          <button type="button" onclick="updateMetarTafLayer('METAR')">Update METAR</button>
        </div>
        <div class="packed-grid">
          <button type="button" onclick="toggleAircraftLayer('Aircraft')">Switch aircraft</button>
          <button type="button" onclick="updateAircraftLayer('Aircraft')">Update aircraft</button>
        </div>
        <div class="packed-grid">
          <button type="button" onclick="toggleAcarsLayer('ACARS')">Switch ACARS</button>
          <button type="button" onclick="updateAcarsLayer('ACARS')">Update ACARS</button>
        </div>
        <div class="packed-grid">
          <button type="button" onclick="toggleFlightpathLayer('Flightpath')">Switch flightpath</button>
          <button type="button" onclick="updateFlightpathLayer('Flightpath')">Update flightpath</button>
        </div>
        <div class="packed-grid">
          <button type="button" onclick="toggleGradientFlightpathLayer('GradientFlightpath')">Switch gradient flightpath</button>
          <button type="button" onclick="updateGradientFlightpathLayer('GradientFlightpath')">Update gradient flightpath</button>
        </div>
        <button type="button" onclick="toggleFlightplanLayer('Flightplan')">Switch flightplan</button>
        <button type="button" onclick="updateForecastLevel()">Update forecast level</button>
        <div class="packed-grid">
          <button type="button" onclick="updateBearing()">Update map bearing</button>
          <button type="button" onclick="resetBearing()">Reset map bearing</button>
        </div>
        <b>Onetime interaction event</b><div id="onetime-interaction"></div>
        <b>Continuous interaction event</b><div id="continuous-interaction"></div>
        <b>Onetime animation event</b><div id="onetime-animation-zoom"></div><div id="onetime-animation-move"></div><div id="onetime-animation-rotate"></div>
        <b>Continuous animation event</b><div id="continuous-animation-zoom"></div><div id="continuous-animation-move"></div>
      </div>
      <div class="iframe-container">
        <!-- clipboard-write is required to be able to copy location coordinates using the KPositionIndicator  -->
        <iframe id="kano" title="Kano" allow="geolocation *; clipboard-write" allowfullscreen src="/">
        </iframe>
      </div>
    </div>
    <script>
      var kano = document.getElementById('kano').contentWindow
      function getEventMessage(type, event) {
        const { latitude, longitude, feature, layer, containerPoint, bearing } = event
        const { x, y } = containerPoint || {}
        let message = type + ' received'
        if (latitude && longitude) message += '<br/>Lat/Long = ' +  latitude.toFixed(2) + ',' + longitude.toFixed(2)
        if (x && y) message += '<br/>X/Y = ' +  x.toFixed(0) + ',' + y.toFixed(0)
        if (bearing !== undefined) message += '<br/>Bearing = ' +  bearing.toFixed(2)
        if (layer) message += '<br/>Layer ' + (layer.label || layer.name)
        if (feature) {
          const id = (layer.featureId ? feature.properties[layer.featureId] : feature._id)
          message += '<br/>Feature ' + id
        }
        return message
      }
      function updateInteraction(type, event) {
        const message = getEventMessage(type, event)
        document.getElementById(type === 'mousemove' || type === 'drag' ? 'continuous-interaction' :  'onetime-interaction').innerHTML = message
      }
      function updateAnimation(type, event) {
        const message = getEventMessage(type, event)
        let id = (type === 'zoom' || type === 'move' ? 'continuous-animation-' + type :  'onetime-animation-')
        if (id === 'onetime-animation-') id += (type.includes('zoom') ? 'zoom' : type.includes('move') ? 'move' : 'rotate')
        document.getElementById(id).innerHTML = message
      }
      postRobot.on('kano-ready', () => {
        // configuration example
        postRobot.send(kano, 'setConfiguration', {
          theme: '#448aff', // Change theme color
          'locale.default': 'en-GB',
          'layout.welcome' : false, // No welcome screen
          'layout.leftPane.filter': { id: { $ne: 'logout' } },
          'mapActivity.topPane.filter': { id: { $nin: ['toggle-fullscreen'] } }, // No fullscreen mode
          'mapActivity.fab.filter': { id: { $in: ['import-layer', 'probe-location'] } },
          'globeActivity.fab.filter': { id: { $in: ['probe-location'] } }, // No import in globe
          // Activate rotation in 2D
          'engines.leaflet.viewer.rotate': true,
          'engines.leaflet.viewer.rotateControl': false,
          // Allow more events to be emitted
          'mapActivity.allowForwardEvents': ['click', 'dblclick', 'contextmenu', 'mouseover', 'mouseout', 'mousemove', 'mousedown', 'mouseup',
            'movestart', 'moveend', 'move', 'zoomstart', 'zoomend', 'zoom', 'rotate', 'dragstart', 'dragend', 'drag']
          // Do not receive these events
          //'mapActivity.disallowForwardEvents': ['mousemove']
        })
        postRobot.send(kano, 'setLocalStorage', {
          'kano-jwt': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJrYWxpc2lvIiwiaXNzIjoia2FsaXNpbyJ9.qwOZjkIcAqo6HPGESu0_5-f6g9VkN6y6pN1HJKJF6Sg'
        })
      })
      postRobot.on('api-ready', () => console.log('Kano API ready'))
      postRobot.on('kano-login', () => console.log('User logged in'))
      postRobot.on('kano-logout', () => console.log('User logged out'))
      postRobot.on('map-ready', async () => {
        console.log('Map component ready')
        // check acces to a service by requesting saved user contexts
        let result = await postRobot.send(kano, 'api', { service: 'catalog', operation: 'find', args: [{ query: { type: 'Context' } }] })
        // Activate first context if any
        let response = result.data
        if (response.total > 0) postRobot.send(kano, component, { command: 'loadContext', args: response.data[0] })
        
        response = await fetch('./airports.geojson')
        airports = await response.json()
        //postRobot.send(kano, 'map', { command: 'setTopPaneVisible', args: false })
      })
      postRobot.on('globe-ready', () => console.log('Globe component ready'))
      postRobot.on('map-destroyed', () => console.log('Map component destroyed'))
      postRobot.on('globe-destroyed', () => console.log('Globe component destroyed'))
      postRobot.on('click', (event) => {
        updateInteraction('click', event.data)
      })
      postRobot.on('dbclick', (event) => {
        updateInteraction('dbclick', event.data)
      })
      postRobot.on('contextmenu', (event) => {
        updateInteraction('contextmenu', event.data)
      })
      postRobot.on('mouseover', (event) => {
        updateInteraction('mouseover', event.data)
      })
      postRobot.on('mouseout', (event) => {
        updateInteraction('mouseout', event.data)
      })
      postRobot.on('mousemove', (event) => {
        updateInteraction('mousemove', event.data)
      })
      postRobot.on('mouseup', (event) => {
        updateInteraction('mouseup', event.data)
      })
      postRobot.on('mousedown', (event) => {
        updateInteraction('mousedown', event.data)
      })
      postRobot.on('dragstart', (event) => {
        updateInteraction('dragstart', event.data)
      })
      postRobot.on('dragend', (event) => {
        updateInteraction('dragend', event.data)
      })
      postRobot.on('drag', (event) => {
        updateInteraction('drag', event.data)
      })
      postRobot.on('movestart', (event) => {
        updateAnimation('movestart', event.data)
      })
      postRobot.on('moveend', (event) => {
        updateAnimation('moveend', event.data)
      })
      postRobot.on('move', (event) => {
        updateAnimation('move', event.data)
      })
      postRobot.on('zoomstart', (event) => {
        updateAnimation('zoomstart', event.data)
      })
      postRobot.on('zoomend', (event) => {
        updateAnimation('zoomend', event.data)
      })
      postRobot.on('zoom', (event) => {
        updateAnimation('zoom', event.data)
      })
      postRobot.on('rotate', (event) => {
        updateAnimation('rotate', event.data)
      })
      postRobot.on('layer-shown', (event) => console.log(event.data.layer.name + ' has been shown'))
      postRobot.on('layer-hidden', (event) => console.log(event.data.layer.name + ' has been hidden'))
      postRobot.on('layer-added', (event) => console.log(event.data.layer.name + ' has been added'))
      postRobot.on('layer-removed', (event) => console.log(event.data.layer.name + ' has been removed'))
      // Layouts related events
      postRobot.on('pane-opened', (event) => console.log(event.data.placement + ' pane has been opened'))
      postRobot.on('pane-closed', (event) => console.log(event.data.placement + ' pane has been closed'))
      postRobot.on('window-opened', (event) => console.log(event.data.placement + ' window has been opened'))
      postRobot.on('window-closed', (event) => console.log(event.data.placement + ' window has been closed'))
      // Extract FR24 data
      var coords = flightradar.geometry.coordinates
      var heights = []
      for (let i=0; i < coords.length; ++i) {
        heights.push(flightradar.properties[i].altitude.feet)
      }
      // We split the path into 3 batches when updating to see gradient changes
      var split = 1.0 / 3.0
    </script>
  </body>
</html>
